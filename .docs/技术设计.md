## 背景与目标

- 背景：现有系统采用 LangGraph 的多智能体编排（Supervisor + Text2SQL/Statistics/Analysis），部分 Agent 已引入 `langmem` 的工具或内存存储，但缺乏一套统一、可扩展、可持久化且具路由策略的长期记忆方案。
- 参考：TinyMem0（受 Mem0 启发）聚焦极简的长期记忆能力，通常包含“写入-检索-更新/合并-删除-路由/触发”的闭环，偏向向量数据库（如 Qdrant）与轻量 LLM（如 Qwen）组合实现。
- 目标：在不破坏现有 Agent 架构的前提下，引入 TinyMem0 风格的长期记忆，统一记忆接口与工具，支持跨会话复用、冲突合并、时效衰减、可观测与可控，优先本地可运行，按需升级到外部向量库。


## 范围变更（重要）

- 统一管理记忆，仅在 `Supervisor` 中实现长期记忆；子 Agent（Text2SQL/Analysis/Statistics）不直接持久化记忆、不注册记忆工具，保持“无状态/轻状态”。
- 记忆的“读/写/合并/删除/路由”均由 `Supervisor` 统一调度与执行；子 Agent 仅消费由 `Supervisor` 注入的上下文记忆片段。


## 现状梳理（与接入点）

- 多 Agent：
  - `SupervisorAgent`（`main.py` 内部类）：通过 `create_react_agent` 管理 handoff 工具，`state_schema=CustomState`，将三个子 Agent 组织成有向图。
  - `Text2SQLAgent`（`agents/sql_agent.py`）：
    - 当前代码中已存在 `InMemoryStore` 与 `langmem` 的工具接入样例。但根据范围变更，后续实现中将移除/停用子 Agent 直接记忆工具注册，全部由 `Supervisor` 接管。
  - `AnalysisAgent`（`agents/analysis_agent.py`）：
    - 初始化了 `InMemoryStore`；根据范围变更，不在该 Agent 内注册或持久化长期记忆。
- 状态模型：`common/memory_state.py` 中存在 `CustomState`（短期）和 `AnalysisMemory`（长期记忆数据结构雏形），但后者未被实际打通。
- 配置：`common/config.py` 含 `EMBEDDING_MODEL/EMBEDDING_DIM` 以及 `QDRANT_URL/QDRANT_KEY` 预留，满足“本地嵌入 + 向量库可选”的技术路线。

结论：优先统一记忆抽象与工具；在 `Supervisor` 与各 Agent 的关键节点（进入/退出、handoff 前后）插入“检索-写入/合并”逻辑；沿用已有 Embedding 配置与本地模型缓存，向量库支持渐进式引入。


## 需求与范围

- 功能需求（Must）
  - 长期记忆持久化：跨会话保留，支持用户级与任务级命名空间隔离。
  - 语义检索：基于嵌入的 Top-K 召回 + 相关性/时间等重排。
  - 记忆写入/更新/合并：避免重复冗余，支持冲突检测和策略化合并。
  - 记忆删除/过期：基于 TTL/衰减/手动删除，保证库“新鲜度”和容量上限。
  - 记忆路由策略：何时写、写哪些、何时读、读多少、何时跳过。
  - 可观测与审计：记录命中/写入日志、可追踪来源，便于评估与回放。

- 非功能需求（Should）
  - 可移植与可回退：默认本地存储可运行，向量库按需切换；失败时回退不影响主链路。
  - 低侵入：尽量通过统一工具/Hook 接入，不大改现有 Agent 提示词与逻辑。
  - 配置化：维度权重、阈值、TTL、命名空间、后端存储等均可配置。

- Out of scope（当前不做）
  - 复杂的元认知/记忆链推理；
  - 多租户隔离的完整管控面板（后续扩展）。


## 记忆类型与数据模型

- 记忆类型（建议按命名空间隔离）
  - 用户画像/偏好（user-profile）：持久度高，变化低，强个性化；
  - 领域事实/结论（domain-facts）：例如某数据口径的结论、图数据库实体关键洞察；
  - 任务履历（task-traces）：某次复杂任务的步骤、最终答案与关键中间结论；
  - 工具使用与副作用（tool-effects）：SQL 查询与文件路径、生成的报表/图像索引等。

- 统一结构（建议在 `common/memory_state.py` 扩展/对齐）
  - id: str（唯一）
  - namespace: str（形如 `agent_name/user_id` 或 `(scope, user_id)`）
  - content: str（记忆主体文本）
  - metadata: dict（如 `{"type": "user-profile", "source": "analysis_agent", "tags": [...], "score": float, "ttl": int}`）
  - created_at/updated_at: int（epoch）
  - embedding: vector（后端维护）


## 存储与索引方案

- 默认（本地优先）：`InMemoryStore` + 本地嵌入（已缓存 `cache/all-MiniLM-L6-v2`）
  - 优点：零依赖、易调试、接入成本低；
  - 缺点：非持久，进程退出即失；
  - 方案：增加轻量持久层（JSON/SQLite）进行周期性落盘或写时双写（见回退策略）。

- 可选升级：Qdrant（与 TinyMem0 对齐）
  - 条件：当需要跨进程/多实例与大规模记忆时启用；
  - 配置：使用 `QDRANT_URL/QDRANT_KEY`，集合名按命名空间动态创建；
  - 兼容：接口抽象为 MemoryBackend（见工具设计）。


## 工具与接口设计（Tool/API）

围绕 TinyMem0 能力定义统一工具，供 `Supervisor`/各 Agent 以 ReAct 方式调用。每个 Tool 均要求携带 `namespace` 与 `langgraph_user_id`（由 `CustomState` 提供）。

- memory.search
  - 入参：`query: str`, `namespace: str`, `top_k: int=5`, `min_score: float=0.3`
  - 出参：`[{id, content, metadata, score}]`
  - 行为：嵌入检索 + 重排（score = α·语义相似 + β·时间衰减 + γ·新鲜度）。

- memory.write
  - 入参：`content: str`, `namespace: str`, `metadata: dict`
  - 出参：`{id, status}`
  - 行为：生成嵌入 → 入库；写入前可先 `search` 检测重复（相似度>阈值 → 走 `update/merge`）。

- memory.update
  - 入参：`id: str`, `content: Optional[str]`, `metadata: Optional[dict]`, `merge: bool=True`
  - 出参：`{id, status}`
  - 行为：合并策略（覆盖/拼接/摘要合并 由 `metadata.strategy` 指定）。

- memory.delete
  - 入参：`id: str` 或 `filters`
  - 出参：`{deleted: int}`
  - 行为：物理删除或软删除（标记并保持向量库一致）。

- memory.summarize（可选）
  - 入参：`items: [id]|[content]`, `goal: str`
  - 出参：`{summary: str}`
  - 行为：对一组命中记忆进行结构化摘要，便于注入提示词。

- memory.route（路由判定）
  - 入参：`message/trace/context`, `policy: str`（默认策略）
  - 出参：`{should_read: bool, should_write: bool, namespaces: [str]}`
  - 行为：基于启发规则与轻量 LLM 结合：例如“用户陈述偏好/设定 → 写 user-profile；跨会话引用 → 读 user-profile/domain-facts”。

实现建议：
- 定义 `MemoryBackend` 接口（`search/write/update/delete/batch`）。提供两种实现：`InMemory+JSON/SQLite` 和 `QdrantBackend`。上层工具只依赖接口。
- 工具名称与 `langmem` 已有工具保持直观一致，便于迁移与复用（当前 `Text2SQLAgent` 已接入 `create_manage_memory_tool` 与 `create_search_memory_tool`，Analysis 需补齐）。


## 路由策略与触发点

- 触发点（Supervisor 主流程）
  1) 进入 `supervisor` 节点前：根据 `CustomState.user_id` 与当前用户问题，调用 `memory.route` → 若 `should_read`，则对各候选命名空间执行 `memory.search`，将命中结果以“系统上下文”注入到 `supervisor_prompt` 的检索补白段落中（限制 token）。
  2) `handoff` 到子 Agent 前：再次基于任务意图选择该 Agent 的命名空间检索（如 `text2sql_memories/{user_id}`、`analysis_memories/{user_id}`）。
  3) 子 Agent 执行完成返回 `final_answer/side_effects` 后：根据 `memory.route` 判定是否写入。优先写入：
     - 用户长期偏好（如报表风格、语言、表字段口径解释）；
     - 关键结论（analysis 最终洞察/指标口径）；
     - 工具副作用（生成的 csv/报告文件路径、关键 SQL）。

- 路由策略（示例启发式 + 轻量 LLM）
  - 用户使用“以后都/默认/记住/偏好/习惯”等词汇 → 写 `user-profile`；
  - 出现稳定事实定义（口径、实体别名映射、图谱节点释义） → 写 `domain-facts`；
  - 长链路任务的中期/最终结论 → 写 `task-traces`（可摘要后写）；
  - 当检索得分 < 阈值或命中过多 → 调整 `top_k` 或跳过，避免噪声注入。


## 与 Supervisor 的集成方案

- 命名空间规范：`{agent_name}_memories/{langgraph_user_id}`；对于通用用户画像使用 `user_profile/{langgraph_user_id}`。
- 注入点：
  - `SupervisorAgent._init_tools`：挂载统一的 Memory 工具（search/write/update/delete/route/summarize）。
  - `SupervisorAgent._init_agent`：在 `prompt=supervisor_prompt` 之前，预留“记忆检索注入段”，例如“相关长期记忆：…（最多 N 条）”。
  - `handoff_tool` 内：将 `state` 中的命中记忆（若存在）附加到 `agent_input.messages` 的系统消息首位，作为子 Agent 的可用上下文。
- 子 Agent 对齐：
  - `Text2SQLAgent`：已具备 memory 工具，需补充“路由判定 + 自动写入关键 SQL 与生成文件路径”的 Hook（结束后写）。
  - `AnalysisAgent`：将 memory 工具加入 `tools`，在生成最终结论时路由写入“关键洞察/口径定义/引用资料索引”等。
- 状态承载：使用 `CustomState.user_id/user_name`；如无则生成匿名 id 并贯穿全链路。


## 评分、衰减与冲突合并

- Relevance Score：语义相似度（余弦）标准化到 [0,1]；
- 时间衰减：`decay = exp(-λ·age_days)`，最终分数 `S = α·sim + β·decay + γ·source_boost`；
- 冲突检测：相似度≥阈值或同标签同主题命中 → 进入合并；
- 合并策略：
  - 覆盖：更新最新内容（适合用户偏好）；
  - 拼接：时间序列追加（适合任务履历）；
  - 摘要合并：LLM 生成去重后的统一表述（适合口径/事实）。


## 安全与隐私

- PII 脱敏：写入前可选脱敏（邮箱/手机号等）；
- 命名空间隔离：按用户、Agent、任务类型；
- 删除权与可撤回：提供删除工具并记录审计；
- 外部向量库（Qdrant）访问控制：API Key，最小权限原则。


## 配置项（建议）

- EMBEDDING_MODEL / EMBEDDING_DIM（已存在）
- MEMORY_BACKEND: in_memory|json|sqlite|qdrant（默认 in_memory）
- MEMORY_TOP_K / MEMORY_MIN_SCORE / MEMORY_DECAY_LAMBDA
- MEMORY_MAX_CONTEXT_TOKENS（注入到提示词的容量上限）
- MEMORY_NAMESPACES（各 Agent 默认命名空间前缀）


## 落地步骤与里程碑

1) 统一 Memory 工具层（search/write/update/delete/route/summarize），抽象 `MemoryBackend` + 本地实现（含 JSON/SQLite 落盘）。
2) 在 `Supervisor` 注入工具与检索注入段；在 handoff 前后调用路由 + 检索/写入。
3) `AnalysisAgent` 接入记忆工具；为 Text2SQL/Analysis 增加结束后“关键事实/副作用”写入 Hook。
4) 加权重排（语义+时间衰减）与冲突合并策略落地；加入基础审计日志。
5) 可选启用 QdrantBackend，并在环境与配置中切换验证。
6) 评估与指标：命中率、辅助上下文利用率、重复写入率、跨会话复用提升率。


## 兼容性与回退策略

- 若记忆后端不可用：自动回退到本地内存；
- 若嵌入失败：跳过记忆流程不阻塞主功能；
- 写时双写（选）：本地 JSON/SQLite + 向量库，提升可靠性。


## 与 TinyMem0 的对齐点

- 极简闭环：检索-写入/合并-删除-路由，统一工具化；
- 轻量依赖：默认本地内存 + 可选 Qdrant；
- 注重策略：通过路由与合并策略降低噪声与遗忘关键事实；
- 易集成：面向 `Supervisor`/Agent 的统一工具与 Hook，不破坏现有流转。


## 任务清单（实现层面拆解）

- 定义 `MemoryBackend` 接口与本地实现（含 JSON/SQLite 落盘）。
- 实现统一工具：`memory.search/write/update/delete/route/summarize`。
- 在 `Supervisor`（唯一记忆入口与出口）：
  - 注册上述工具；
  - 在进入 `supervisor` 与 handoff 前做检索注入（仅 `Supervisor` 操作）；
  - 在子 Agent 返回后由 `Supervisor` 统一写入关键结论/副作用（子 Agent 不直接写记忆）。
- 评分/衰减/合并策略配置化与实现；
- 审计日志与最小可观测（命中/写入统计）。


## 成功标准（验收）

- 功能：能跨会话记住用户偏好与关键结论，能检索并注入提升回答质量；
- 质量：重复记忆合并率>80%，无明显语义冲突；
- 稳定：记忆后端异常不影响主流程；
- 易用：通过配置切换后端（本地/Qdrant），无改代码。